package com.kojstarinnovations.repository.infraestructure.output.persistence.repository.impl;

import com.kojstarinnovations.repository.application.annotations.AutoGenerated;
import com.kojstarinnovations.repository.application.annotations.Id;
import com.kojstarinnovations.repository.application.annotations.Param;
import com.kojstarinnovations.repository.application.annotations.Query;
import com.kojstarinnovations.repository.application.exceptions.NotFoundException;
import com.kojstarinnovations.repository.application.exceptions.SQLExceptionCustomized;
import com.kojstarinnovations.repository.domain.connection.CustomizedConnection;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.math.BigInteger;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.logging.Logger;

import static com.kojstarinnovations.repository.infraestructure.output.persistence.repository.impl.ReflectionUtils.toSnakeCase;

/**
 * Class to implement the repository
 *
 * @param <ENTITY> the entity
 * @param <ID> the id
 * @Author: KojstarInnovations
 */
public class RepositoryImpl<ENTITY, ID> implements Repository<ENTITY, ID> {

    private final Connection connection;
    private final Class<ENTITY> entity;

    public RepositoryImpl(Class<ENTITY> entity, Connection connection) {
        this.entity = entity;
        this.connection = connection;
    }

    @Override
    public ENTITY save(ENTITY entity) {
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            List<Field> fields = ReflectionUtils.getAllFields(entity.getClass());
            StringBuilder query = new StringBuilder("INSERT INTO " + entity.getClass().getSimpleName() + " (");
            StringBuilder values = new StringBuilder(") VALUES (");
            boolean isIdAutoGenerated = false;

            Field idField = checkId(fields);

            for (Field field : fields) {
                field.setAccessible(true);
                if (field.isAnnotationPresent(AutoGenerated.class)) {
                    isIdAutoGenerated = true;
                    idField = field;
                }
                query.append(toSnakeCase(field.getName())).append(", ");
                values.append("?, ");
            }

            query.delete(query.length() - 2, query.length());
            values.delete(values.length() - 2, values.length());
            query.append(values).append(")");

            if (isIdAutoGenerated) {
                preparedStatement = connection.prepareStatement(query.toString(), Statement.RETURN_GENERATED_KEYS);
            } else {
                preparedStatement = connection.prepareStatement(query.toString());
            }

            for (int i = 0; i < fields.size(); i++) {
                fields.get(i).setAccessible(true);
                preparedStatement.setObject(i + 1, fields.get(i).get(entity));
            }

            preparedStatement.executeUpdate();

            if (isIdAutoGenerated) {
                resultSet = preparedStatement.getGeneratedKeys();
                if (resultSet.next()) { // Set the generated id
                    Object generatedId = resultSet.getObject(1);
                    if (generatedId instanceof BigInteger) {
                        // Convert BigInteger to Integer
                        idField.set(entity, ((BigInteger) generatedId).intValue());
                    } else {
                        // If not a BigInteger, assume it's compatible with Integer
                        idField.set(entity, generatedId);
                    }
                }
            }

            return entity;
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLExceptionCustomized(e.getMessage());
        } finally {
            CustomizedConnection.closeResultSet(resultSet);
            CustomizedConnection.closePreparedStatement(preparedStatement);
        }
    }

    private Field checkId(List<Field> fields) {
        Field idField = null;

        for (Field field : fields) {
            if (field.isAnnotationPresent(Id.class)) {
                idField = field;
                break;
            }
        }

        if (idField == null) {
            throw new IllegalStateException("No field annotated with @Id found in entity class");
        }

        return idField;
    }

    @Override
    public Optional<ENTITY> getById(ID id) {
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            List<Field> fields = ReflectionUtils.getAllFields(entity);
            Field idField = checkId(fields);

            String query = String.format("SELECT * FROM %s WHERE %s = ?", entity.getSimpleName(), toSnakeCase(idField.getName()));
            preparedStatement = connection.prepareStatement(query);
            preparedStatement.setObject(1, id);

            resultSet = preparedStatement.executeQuery();

            if (resultSet.next()) {
                ENTITY entityInstance = entity.getDeclaredConstructor().newInstance();

                for (Field field : fields) {
                    field.setAccessible(true);
                    String columnName = toSnakeCase(field.getName());
                    Object value = resultSet.getObject(columnName);

                    // Handle conversion from SQL types to Java types
                    if (value instanceof Timestamp && field.getType().equals(LocalDateTime.class)) {
                        value = ((Timestamp) value).toLocalDateTime();
                    }

                    //Sql date to local date
                    if (value instanceof Date && field.getType().equals(LocalDate.class)) {
                        value = ((Date) value).toLocalDate();
                    }

                    field.set(entityInstance, value);
                }

                return Optional.of(entityInstance);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLExceptionCustomized(e.getMessage());
        } finally {
            CustomizedConnection.closeResultSet(resultSet);
            CustomizedConnection.closePreparedStatement(preparedStatement);
        }
    }

    @Override
    public ENTITY update(ENTITY entity) {
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            List<Field> fields = ReflectionUtils.getAllFields(entity.getClass());
            StringBuilder query = new StringBuilder("UPDATE " + entity.getClass().getSimpleName() + " SET ");
            Field idField = checkId(fields);

            query.delete(query.length() - 2, query.length());
            query.append(" WHERE ").append(toSnakeCase(idField.getName())).append(" = ?");

            preparedStatement = connection.prepareStatement(query.toString());

            for (int i = 0; i < fields.size(); i++) {
                fields.get(i).setAccessible(true);
                preparedStatement.setObject(i + 1, fields.get(i).get(entity));
            }

            preparedStatement.setObject(fields.size() + 1, idField.get(entity));

            preparedStatement.executeUpdate();

            return entity;
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLExceptionCustomized(e.getMessage());
        } finally {
            CustomizedConnection.closeResultSet(resultSet);
            CustomizedConnection.closePreparedStatement(preparedStatement);
        }
    }

    /**
     * Method to delete an entity
     *
     * @param entity the entity to be deleted
     */
    @Override
    public void delete(ENTITY entity) {
    }

    /**
     * Method to get all entities
     *
     * @return all entities
     */
    @Override
    public List<ENTITY> getAll() {
        return null;
    }

    /**
     * Method to get a page of entities
     *
     * @param values the value of the field to be retrieved
     * @return a page of entities
     */

    private Optional<ENTITY> findByGenericQuery(String query, List<Object> values) {
        Logger.getLogger(RepositoryImpl.class.getName()).info("Executing query: " + query);

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            preparedStatement = connection.prepareStatement(query);
            for (int i = 0; i < values.size(); i++) {
                preparedStatement.setObject(i + 1, values.get(i));
            }

            resultSet = preparedStatement.executeQuery();

            resultSet.next();

            return Optional.of(ReflectionUtils.getObjectFromResultSet(resultSet, entity));
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLExceptionCustomized(e.getMessage());
        } finally {
            CustomizedConnection.closeResultSet(resultSet);
            CustomizedConnection.closePreparedStatement(preparedStatement);
        }
    }

    /**
     * Method to evaluate if an entity exists by id
     *
     * @param id the id of the entity to be evaluated
     * @return true if the entity exists, false otherwise
     */
    @Override
    public boolean existsById(ID id) {
        return false;
    }

    /**
     * Method to evaluate if an entity exists by generic field
     *
     * @param value the value of the field to be evaluated
     * @return true if the entity exists, false otherwise
     */
    private boolean existsByGenericField(String query, List<Object> value) {

        Logger.getLogger(RepositoryImpl.class.getName()).info("Executing query: " + query);

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            preparedStatement = connection.prepareStatement(query);
            for (int i = 0; i < value.size(); i++) {
                preparedStatement.setObject(i + 1, value.get(i));
            }

            resultSet = preparedStatement.executeQuery();

            resultSet.next();

            return resultSet.getBoolean(1);
        } catch (Exception e) {
            e.printStackTrace();
            throw new SQLExceptionCustomized(e.getMessage());
        } finally {
            CustomizedConnection.closeResultSet(resultSet);
            CustomizedConnection.closePreparedStatement(preparedStatement);
        }
    }

    protected String getQuery(Method method) {
        if (method.isAnnotationPresent(Query.class)) {
            Query queryAnnotation = method.getAnnotation(Query.class);
            return queryAnnotation.value();
        }

        return null;
    }

    private Method findMethod(Class<?> repository, String methodName, List<Object> values) throws NoSuchMethodException {
        Class<?>[] paramTypes = values.stream().map(Object::getClass).toArray(Class[]::new);
        return repository.getMethod(methodName, paramTypes);
    }

    private String constructSelectQuery(Method method) {
        String query = getQuery(method);

        if (query != null) {
            return query;
        }

        Parameter[] parameters = method.getParameters();

        StringBuilder queryBuilder = new StringBuilder("SELECT * FROM ");
        queryBuilder.append(entity.getSimpleName());
        queryBuilder.append(" WHERE ");

        for (int i = 0; i < parameters.length; i++) {
            Annotation[] paramAnnotations = parameters[i].getAnnotations();
            for (Annotation annotation : paramAnnotations) {
                if (annotation instanceof Param param) {
                    queryBuilder.append(toSnakeCase(param.value())).append(" = ?");
                    if (i < parameters.length - 1) {
                        queryBuilder.append(" AND ");
                    }
                }
            }
        }

        queryBuilder.append(";");
        return queryBuilder.toString();
    }

    private String constructExistQuery(Method method) {
        String query = getQuery(method);

        if (query != null) {
            return query;
        }

        Parameter[] parameters = method.getParameters();

        StringBuilder queryBuilder = new StringBuilder("SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END FROM ");
        queryBuilder.append(entity.getSimpleName());
        queryBuilder.append(" WHERE ");

        for (int i = 0; i < parameters.length; i++) {
            Annotation[] paramAnnotations = parameters[i].getAnnotations();
            for (Annotation annotation : paramAnnotations) {
                if (annotation instanceof Param param) {
                    queryBuilder.append(toSnakeCase(param.value())).append(" = ?");
                    if (i < parameters.length - 1) {
                        queryBuilder.append(" AND ");
                    }
                }
            }
        }

        queryBuilder.append(";");
        return queryBuilder.toString();
    }

    @Override
    public Optional<ENTITY> findByGenericMethod(String methodName, Class<?> repository, List<Object> values) {
        try {
            return findByGenericQuery(constructSelectQuery(findMethod(repository, methodName, values)), values);
        } catch (NoSuchMethodException e) {
            throw new NotFoundException("Method not found");
        }
    }

    @Override
    public boolean existsByGenericMethod(String methodName, Class<?> repository, List<Object> values) {
        try {
            return existsByGenericField(constructExistQuery(findMethod(repository, methodName, values)), values);
        } catch (NoSuchMethodException e) {
            throw new NotFoundException("Method not found");
        }
    }
}
